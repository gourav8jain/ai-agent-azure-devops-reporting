import smtplib
import os
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from datetime import datetime
from dotenv import load_dotenv
from config import Config

# Load .env file for local development (if it exists)
# GitHub Actions will use repository secrets instead
load_dotenv()

def validate_html_has_data(html_content):
    """Validate that HTML content contains actual sprint data (not just zeros)"""
    # Check for empty data indicators in HTML
    import re
    
    # Check if Total Work Items is 0
    # Pattern: <h3>Total Work Items</h3> followed by <div>0</div>
    work_items_match = re.search(r'Total Work Items.*?<div[^>]*>[\s]*(\d+)[\s]*</div>', html_content, re.DOTALL)
    if work_items_match:
        count = int(work_items_match.group(1))
        if count == 0:
            return False
    
    # Check if Projects count is 0
    projects_match = re.search(r'Projects.*?<div[^>]*>[\s]*(\d+)[\s]*</div>', html_content, re.DOTALL)
    if projects_match:
        count = int(projects_match.group(1))
        if count == 0:
            return False
    
    # Check if Engineers count is 0
    engineers_match = re.search(r'Engineers.*?<div[^>]*>[\s]*(\d+)[\s]*</div>', html_content, re.DOTALL)
    if engineers_match:
        count = int(engineers_match.group(1))
        if count == 0:
            return False
    
    # Check if there are any project sections with actual data
    # Look for project sections that aren't just empty headers
    if not re.search(r'<!-- Project Section:', html_content):
        return False
    
    return True

def send_email_directly(html_filename, html_content):
    """Send email directly using Gmail credentials from environment variables"""
    
    # Validate HTML content has data before sending
    if not validate_html_has_data(html_content):
        print("âŒ HTML content contains no data (all zeros). Refusing to send empty email.")
        return False
    
    # Get email configuration from Config
    EMAIL_FROM = Config.EMAIL_FROM
    EMAIL_TO_MULTIPLE = Config.EMAIL_TO_MULTIPLE
    EMAIL_TO = Config.EMAIL_TO
    SMTP_SERVER = Config.SMTP_SERVER
    SMTP_PORT = Config.SMTP_PORT
    SMTP_USERNAME = Config.SMTP_USERNAME
    SMTP_PASSWORD = Config.SMTP_PASSWORD
    
    # Get recipients (single or multiple)
    recipients = Config.get_email_recipients()
    
    if not all([EMAIL_FROM, SMTP_USERNAME, SMTP_PASSWORD]) or not recipients:
        print("âŒ Missing required email credentials in environment variables")
        print("Please set EMAIL_FROM, EMAIL_TO (or EMAIL_TO_MULTIPLE), SMTP_USERNAME, and SMTP_PASSWORD")
        return False
    
    print(f"ðŸ“§ Sending email with credentials from environment...")
    print(f"   From: {EMAIL_FROM}")
    print(f"   To: {', '.join(recipients)}")
    print(f"   SMTP: {SMTP_SERVER}:{SMTP_PORT}")
    
    # Create message
    msg = MIMEMultipart('alternative')
    msg['From'] = EMAIL_FROM
    msg['To'] = ', '.join(recipients)  # Multiple recipients
    msg['Subject'] = f"Sprint Report - Daily - {datetime.now().strftime('%B %d, %Y')} - IOL Pay & VCC"
    
    # Resolve overall sprint period dynamically for email text body
    overall_period = Config.get_current_sprint_period()
    overall_start = overall_period.get('start_date', '')
    overall_end = overall_period.get('end_date', '')

    # Create text body
    text_body = f"""
Sprint Report - Daily - {datetime.now().strftime('%B %d, %Y')} - IOL Pay & VCC

This report contains sprint data for the current period.

Generated by Azure DevOps AI Agent

Sprint Period: {overall_start} - {overall_end}

For full formatted report, please view this email in HTML format.
    """
    
    # Create HTML body
    html_body = MIMEText(html_content, 'html')
    
    # Attach both text and HTML
    msg.attach(MIMEText(text_body, 'plain'))
    msg.attach(html_body)
    
    try:
        print(f"   ðŸ”„ Connecting to Gmail SMTP...")
        
        # Connect to Gmail SMTP
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        
        print(f"   ðŸ” Authenticating with Gmail...")
        server.login(SMTP_USERNAME, SMTP_PASSWORD)
        
        print(f"   ðŸ“¤ Sending email...")
        text = msg.as_string()
        server.sendmail(EMAIL_FROM, recipients, text)
        server.quit()
        
        print(f"   âœ… Email sent successfully!")
        return True
        
    except Exception as e:
        print(f"   âŒ Failed to send email: {str(e)}")
        
        if "Application-specific password required" in str(e):
            print(f"\nðŸ’¡ Gmail requires an App Password for security.")
            print(f"   To fix this:")
            print(f"   1. Go to https://myaccount.google.com/")
            print(f"   2. Navigate to Security â†’ 2-Step Verification")
            print(f"   3. Scroll down to 'App passwords'")
            print(f"   4. Generate a new app password for 'Mail'")
            print(f"   5. Use that password instead of your regular password")
        
        elif "Username and Password not accepted" in str(e):
            print(f"\nðŸ’¡ Gmail authentication failed.")
            print(f"   Please check:")
            print(f"   1. Username: {SMTP_USERNAME}")
            print(f"   2. Password: {SMTP_PASSWORD}")
            print(f"   3. 2-Step Verification is enabled")
        
        return False

def find_non_empty_html_report():
    """Find the most recent HTML report that has actual data"""
    # Find the most recent HTML report (prefer compact version)
    html_files = [f for f in os.listdir('.') if f.startswith('compact_sprint_report_') and f.endswith('.html')]
    if not html_files:
        # Fallback to regular sprint reports
        html_files = [f for f in os.listdir('.') if f.startswith('sprint_report_') and f.endswith('.html')]
    if not html_files:
        return None, "No HTML reports found"
    
    # Sort by modification time (most recent first)
    html_files.sort(key=lambda x: os.path.getmtime(x), reverse=True)
    
    # Try each HTML file until we find one with data
    for html_file in html_files:
        try:
            with open(html_file, 'r', encoding='utf-8') as f:
                html_content = f.read()
            
            if validate_html_has_data(html_content):
                return html_file, html_content
        except Exception as e:
            print(f"   âš ï¸ Error reading {html_file}: {str(e)}")
            continue
    
    return None, "No HTML reports with data found"

def main():
    """Main function to send email directly"""
    print("ðŸ“§ Direct Email Sender with Environment Variables")
    print("=" * 60)
    
    # ALWAYS regenerate HTML from latest JSON to ensure fresh data
    print("ðŸ”„ Regenerating HTML report from latest JSON data...")
    
    try:
        from generate_html_report_compact import generate_compact_html_report
        import json
        
        # Find latest JSON file
        data_dir = 'data'
        json_files = []
        if os.path.exists(data_dir):
            json_files = [f for f in os.listdir(data_dir) if f.startswith('sprint_count_') and f.endswith('.json')]
        
        # Also check current directory for backward compatibility
        if not json_files:
            json_files = [f for f in os.listdir('.') if f.startswith('sprint_count_') and f.endswith('.json')]
            if json_files:
                latest_json = max(json_files, key=lambda x: os.path.getmtime(x))
                latest_json_path = latest_json
            else:
                print(f"âŒ No JSON data files found. Run get_sprint_count.py first.")
                return
        else:
            latest_json = max(json_files, key=lambda x: os.path.getmtime(os.path.join(data_dir, x)))
            latest_json_path = os.path.join(data_dir, latest_json)
        
        # Check if JSON has data
        with open(latest_json_path, 'r', encoding='utf-8') as f:
            json_data = json.load(f)
        
        # Validate JSON has actual data (not empty dict or empty projects)
        if not json_data:
            print(f"âŒ JSON file {latest_json} is empty. No sprint data available.")
            return
        
        # Check if any project has work items
        total_items = sum(result.get('total_items', 0) for result in json_data.values())
        if total_items == 0:
            print(f"âŒ JSON file {latest_json} contains no work items (all zeros).")
            print(f"ðŸ’¡ Please ensure sprint data is available in Azure DevOps.")
            return
        
        print(f"ðŸ“ Found JSON data: {latest_json}")
        print(f"ðŸ“Š Total work items: {total_items}")
        print(f"ðŸ”„ Generating HTML report...")
        
        html_content = generate_compact_html_report(latest_json_path)
        
        if not html_content:
            print(f"âŒ Failed to generate HTML report.")
            return
        
        # Validate HTML content has data
        if not validate_html_has_data(html_content):
            print(f"âŒ Generated HTML report contains no data (all zeros).")
            print(f"ðŸ’¡ This might indicate a problem with the HTML generation.")
            return
        
        # Save the regenerated HTML
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        html_file = f'compact_sprint_report_{timestamp}.html'
        with open(html_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
        print(f"âœ… Generated HTML report: {html_file}")
        
    except FileNotFoundError as e:
        print(f"âŒ JSON file not found: {str(e)}")
        print(f"ðŸ’¡ Please run get_sprint_count.py first to fetch sprint data.")
        return
    except json.JSONDecodeError as e:
        print(f"âŒ Invalid JSON file: {str(e)}")
        return
    except Exception as e:
        print(f"âŒ Error generating report: {str(e)}")
        import traceback
        traceback.print_exc()
        return
    
    print(f"ðŸ“ Using report: {html_file}")
    
    print(f"\nðŸ“§ Email Details:")
    print(f"   Subject: Sprint Report - Daily - {datetime.now().strftime('%B %d, %Y')} - IOL Pay & VCC")
    print(f"   Content: HTML report in email body")
    print(f"   Size: {len(html_content)} characters")
    
    # Send the email
    success = send_email_directly(html_file, html_content)
    
    if success:
        print(f"\nðŸŽ‰ Email sent successfully!")
        print(f"ðŸ“§ Check your email at: {os.getenv('EMAIL_TO', 'your email')}")
        print(f"ðŸ’» The HTML report is now in the email body!")
    else:
        print(f"\nâŒ Email sending failed.")
        print(f"ðŸ’¡ Please check your environment variables and try again.")

if __name__ == "__main__":
    main()
