import smtplib
import os
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from datetime import datetime
from dotenv import load_dotenv
from config import Config

# Load .env file for local development (if it exists)
# GitHub Actions will use repository secrets instead
load_dotenv()

def send_email_directly(html_filename, html_content):
    """Send email directly using Gmail credentials from environment variables"""
    
    # Get email configuration from Config
    EMAIL_FROM = Config.EMAIL_FROM
    EMAIL_TO_MULTIPLE = Config.EMAIL_TO_MULTIPLE
    EMAIL_TO = Config.EMAIL_TO
    SMTP_SERVER = Config.SMTP_SERVER
    SMTP_PORT = Config.SMTP_PORT
    SMTP_USERNAME = Config.SMTP_USERNAME
    SMTP_PASSWORD = Config.SMTP_PASSWORD
    
    # Get recipients (single or multiple)
    recipients = Config.get_email_recipients()
    
    if not all([EMAIL_FROM, SMTP_USERNAME, SMTP_PASSWORD]) or not recipients:
        print("‚ùå Missing required email credentials in environment variables")
        print("Please set EMAIL_FROM, EMAIL_TO (or EMAIL_TO_MULTIPLE), SMTP_USERNAME, and SMTP_PASSWORD")
        return False
    
    print(f"üìß Sending email with credentials from environment...")
    print(f"   From: {EMAIL_FROM}")
    print(f"   To: {', '.join(recipients)}")
    print(f"   SMTP: {SMTP_SERVER}:{SMTP_PORT}")
    
    # Create message
    msg = MIMEMultipart('alternative')
    msg['From'] = EMAIL_FROM
    msg['To'] = ', '.join(recipients)  # Multiple recipients
    msg['Subject'] = f"IOL Pay + VCC Sprint Report - Daily - {datetime.now().strftime('%B %d, %Y')}"
    
    # Create text body
    text_body = f"""
IOL Pay + VCC Sprint Report - Daily - {datetime.now().strftime('%B %d, %Y')}

This report contains sprint data for the current period: IOL Pay (Iteration-28) and VCC (Sprint-11)

Generated by Azure DevOps AI Agent

Report Summary:
- IOL Pay (Iteration-28): Current sprint work items
- VCC (Sprint-11): Current sprint work items
- Sprint Period: Oct 14 - Oct 27, 2024

For full formatted report, please view this email in HTML format.
    """
    
    # Create HTML body
    html_body = MIMEText(html_content, 'html')
    
    # Attach both text and HTML
    msg.attach(MIMEText(text_body, 'plain'))
    msg.attach(html_body)
    
    try:
        print(f"   üîÑ Connecting to Gmail SMTP...")
        
        # Connect to Gmail SMTP
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        
        print(f"   üîê Authenticating with Gmail...")
        server.login(SMTP_USERNAME, SMTP_PASSWORD)
        
        print(f"   üì§ Sending email...")
        text = msg.as_string()
        server.sendmail(EMAIL_FROM, recipients, text)
        server.quit()
        
        print(f"   ‚úÖ Email sent successfully!")
        return True
        
    except Exception as e:
        print(f"   ‚ùå Failed to send email: {str(e)}")
        
        if "Application-specific password required" in str(e):
            print(f"\nüí° Gmail requires an App Password for security.")
            print(f"   To fix this:")
            print(f"   1. Go to https://myaccount.google.com/")
            print(f"   2. Navigate to Security ‚Üí 2-Step Verification")
            print(f"   3. Scroll down to 'App passwords'")
            print(f"   4. Generate a new app password for 'Mail'")
            print(f"   5. Use that password instead of your regular password")
        
        elif "Username and Password not accepted" in str(e):
            print(f"\nüí° Gmail authentication failed.")
            print(f"   Please check:")
            print(f"   1. Username: {SMTP_USERNAME}")
            print(f"   2. Password: {SMTP_PASSWORD}")
            print(f"   3. 2-Step Verification is enabled")
        
        return False

def main():
    """Main function to send email directly"""
    print("üìß Direct Email Sender with Environment Variables")
    print("=" * 60)
    
    # Find the most recent HTML report (prefer compact version)
    html_files = [f for f in os.listdir('.') if f.startswith('compact_sprint_report_') and f.endswith('.html')]
    if not html_files:
        # Fallback to regular sprint reports
        html_files = [f for f in os.listdir('.') if f.startswith('sprint_report_') and f.endswith('.html')]
    if not html_files:
        print("‚ùå No HTML reports found. Generate a report first using generate_html_report.py")
        return
    
    latest_report = max(html_files, key=lambda x: os.path.getctime(x))
    print(f"üìÅ Using report: {latest_report}")
    
    # Read the HTML content
    try:
        with open(latest_report, 'r', encoding='utf-8') as f:
            html_content = f.read()
        
        print(f"\nüìß Email Details:")
        print(f"   Subject: Azure DevOps Sprint Report - {datetime.now().strftime('%B %d, %Y')}")
        print(f"   Content: HTML report in email body")
        print(f"   Size: {len(html_content)} characters")
        
        # Send the email
        success = send_email_directly(latest_report, html_content)
        
        if success:
            print(f"\nüéâ Email sent successfully!")
            print(f"üìß Check your email at: {os.getenv('EMAIL_TO', 'your email')}")
            print(f"üíª The HTML report is now in the email body!")
        else:
            print(f"\n‚ùå Email sending failed.")
            print(f"üí° Please check your environment variables and try again.")
            
    except Exception as e:
        print(f"‚ùå Error reading HTML report: {str(e)}")

if __name__ == "__main__":
    main()
